Add this to it:
import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * CredAble “AI Brain Walkthrough”
 *
 * Single-pane visualization:
 * - SVG neural network with 5 separated clickable lanes (layers)
 * - Layer explanation appears as an in-network popup
 * - Bottom-of-page layer controls (1–5) + Prev/Next + Autoplay
 *
 * Notes:
 * - This is a conceptual, explainable visualization (not a model-weight viewer).
 * - No external dependencies.
 */

const LAYERS = [
  {
    key: "perception",
    title: "Layer 1 — Perception",
    subtitle: "What CredAble sees",
    bullets: [
      "Bank transactions & cash flows",
      "GST / tax signals",
      "Financial statements",
      "Invoices, payables & receivables",
      "BRE outputs & application docs",
    ],
  },
  {
    key: "understanding",
    title: "Layer 2 — Understanding",
    subtitle: "What CredAble understands",
    bullets: [
      "Normalize entities (customers, suppliers)",
      "Compute ratios & cycles (DSO/DPO/CCC)",
      "Detect seasonality & volatility",
      "Link documents to facts",
      "Coverage + confidence per signal",
    ],
  },
  {
    key: "reasoning",
    title: "Layer 3 — Reasoning",
    subtitle: "What CredAble infers",
    bullets: [
      "Signals → inferences → implications",
      "Concentration + stress detection",
      "Inconsistency checks",
      "Early warning triggers",
      "Explainable chains with confidence",
    ],
  },
  {
    key: "judgment",
    title: "Layer 4 — Judgment",
    subtitle: "What CredAble would decide",
    bullets: [
      "Policy alignment & exceptions",
      "Risk appetite fit",
      "Scenario sensitivity",
      "Confidence rings + assumptions",
      "Human override + audit trail",
    ],
  },
  {
    key: "action",
    title: "Layer 5 — Action",
    subtitle: "What CredAble produces",
    bullets: [
      "Draft CAM paragraphs",
      "Recommended covenants",
      "Red flags & follow-ups",
      "Decision-ready summary",
      "Notifications for maker/checker",
    ],
  },
] as const;

// ---------- Types ----------

type Node = {
  id: string;
  x: number; // 0..1
  y: number; // 0..1
  layer: number; // 0..4
  r: number;
};

type Edge = {
  a: string;
  b: string;
  strength: number; // 0..1
};

// ---------- Utils ----------

const clamp = (n: number, a: number, b: number) => Math.max(a, Math.min(b, n));

function seededRand(seed: number) {
  // deterministic pseudo-random (Mulberry32)
  let t = seed >>> 0;
  return () => {
    t += 0x6d2b79f5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

function bezier(x1: number, y1: number, x2: number, y2: number) {
  // Calm, schematic bezier for links
  const dx = x2 - x1;
  const dy = y2 - y1;
  const c1x = x1 + dx * 0.35;
  const c2x = x1 + dx * 0.65;
  const c1y = y1 + dy * 0.12;
  const c2y = y2 - dy * 0.12;
  return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
}

function buildBrainGraph(seed = 1337) {
  const rnd = seededRand(seed);

  const nodes: Node[] = [];

  // Inputs
  for (let i = 0; i < 10; i++) {
    nodes.push({
      id: `in-${i}`,
      x: 0.08 + rnd() * 0.06,
      y: 0.15 + (i / 9) * 0.7 + (rnd() - 0.5) * 0.03,
      layer: 0,
      r: 4 + rnd() * 3,
    });
  }

  // Brain core nodes across 5 layers (simplified)
  const layerCounts = [6, 6, 6, 5, 4];

  // Layer lane centers (must match BrainSVG lane proportions)
  const laneCenters = [0.18, 0.34, 0.5, 0.66, 0.82];

  for (let layer = 0; layer < 5; layer++) {
    const count = layerCounts[layer];
    const cx = laneCenters[layer];

    for (let i = 0; i < count; i++) {
      const t = count === 1 ? 0.5 : i / (count - 1);
      const y = 0.18 + t * 0.64 + (rnd() - 0.5) * 0.02; // 0.18..0.82
      const x = cx + (rnd() - 0.5) * 0.03; // stay inside lane

      nodes.push({
        id: `n-${layer}-${i}`,
        x: clamp(x, cx - 0.05, cx + 0.05),
        y: clamp(y, 0.14, 0.86),
        layer,
        r: 3.5,
      });
    }
  }

  // Outputs
  for (let i = 0; i < 7; i++) {
    nodes.push({
      id: `out-${i}`,
      x: 0.88 + rnd() * 0.06,
      y: 0.2 + (i / 6) * 0.6 + (rnd() - 0.5) * 0.03,
      layer: 4,
      r: 4 + rnd() * 3,
    });
  }

  const nodeMap = new Map(nodes.map((n) => [n.id, n] as const));
  const edges: Edge[] = [];

  // Connect inputs to early brain nodes (layer 0 and 1)
  const early = nodes.filter((n) => n.id.startsWith("n-0-") || n.id.startsWith("n-1-"));
  for (let i = 0; i < 10; i++) {
    const a = `in-${i}`;
    for (let k = 0; k < 2; k++) {
      const b = early[Math.floor(rnd() * early.length)]?.id;
      if (b) edges.push({ a, b, strength: 0.45 + rnd() * 0.55 });
    }
  }

  // Connect between layers (structured)
  for (let layer = 0; layer < 4; layer++) {
    const A = nodes.filter((n) => n.id.startsWith(`n-${layer}-`));
    const B = nodes.filter((n) => n.id.startsWith(`n-${layer + 1}-`));

    for (const aNode of A) {
      const targetY = aNode.y;
      // pick a near-y node to keep the wiring readable
      const candidates = B
        .map((b) => ({ id: b.id, d: Math.abs(b.y - targetY) + rnd() * 0.12 }))
        .sort((p, q) => p.d - q.d)
        .slice(0, 4);

      const chosen = candidates[Math.floor(rnd() * candidates.length)]?.id;
      if (chosen) edges.push({ a: aNode.id, b: chosen, strength: 0.35 + rnd() * 0.65 });
    }
  }

  // Connect late layer nodes to outputs
  const last = nodes.filter((n) => n.id.startsWith("n-4-"));
  const outs = nodes.filter((n) => n.id.startsWith("out-"));
  for (const o of outs) {
    for (let k = 0; k < 2; k++) {
      const b = last[Math.floor(rnd() * last.length)]?.id;
      if (b) edges.push({ a: b, b: o.id, strength: 0.45 + rnd() * 0.55 });
    }
  }

  // Deduplicate edges and ensure endpoints exist
  const seen = new Set<string>();
  const deduped: Edge[] = [];
  for (const e of edges) {
    const key = e.a < e.b ? `${e.a}__${e.b}` : `${e.b}__${e.a}`;
    if (seen.has(key)) continue;
    seen.add(key);
    if (nodeMap.has(e.a) && nodeMap.has(e.b)) deduped.push(e);
  }

  return { nodes, edges: deduped };
}

function usePrefersReducedMotion() {
  const [reduced, setReduced] = useState(false);
  useEffect(() => {
    const mq = window.matchMedia?.("(prefers-reduced-motion: reduce)");
    if (!mq) return;
    const onChange = () => setReduced(!!mq.matches);
    onChange();
    mq.addEventListener?.("change", onChange);
    return () => mq.removeEventListener?.("change", onChange);
  }, []);
  return reduced;
}

// ---------- Main Component ----------

export default function CredAbleAIBrainWalkthrough() {
  const prefersReducedMotion = usePrefersReducedMotion();
  const [{ nodes, edges }] = useState(() => buildBrainGraph(1337));

  const [step, setStep] = useState(0);
  const [autoPlay, setAutoPlay] = useState(false);
  const [showPopup, setShowPopup] = useState(true);

  // subtle animation ticker
  const tickRef = useRef(0);
  const [, force] = useState(0);
  useEffect(() => {
    if (prefersReducedMotion) return;
    let raf = 0;
    const loop = () => {
      tickRef.current += 1;
      force((x) => (x + 1) % 1000000);
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(raf);
  }, [prefersReducedMotion]);

  useEffect(() => {
    if (!autoPlay) return;
    const t = window.setInterval(() => {
      setStep((s) => (s + 1) % LAYERS.length);
      setShowPopup(true);
    }, 3200);
    return () => window.clearInterval(t);
  }, [autoPlay]);

  const selectLayer = (i: number) => {
    setStep(i);
    setShowPopup(true);
  };

  const dims = { w: 1200, h: 650 };
  const viewBox = `0 0 ${dims.w} ${dims.h}`;

  const nodePx = useMemo(() => {
    const map = new Map<string, { x: number; y: number; r: number; layer: number }>();
    for (const n of nodes) {
      map.set(n.id, {
        x: n.x * dims.w,
        y: n.y * dims.h,
        r: n.r,
        layer: n.layer,
      });
    }
    return map;
  }, [nodes]);

  const phase = prefersReducedMotion ? 0 : tickRef.current / 24;

  return (
    <div className="min-h-screen w-full bg-slate-50 text-slate-900">
      <div className="mx-auto max-w-6xl px-5 py-10">
        <header className="flex flex-col gap-3">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="inline-flex items-center gap-2">
              <span className="inline-flex h-8 w-8 items-center justify-center rounded-xl bg-white shadow-sm ring-1 ring-slate-200">
                <span className="text-sm font-semibold">C</span>
              </span>
              <div className="text-sm text-slate-500">CredAble • DataBrain Walkthrough</div>
            </div>

            <button
              onClick={() => setAutoPlay((v) => !v)}
              className={`rounded-xl px-3 py-2 text-sm font-semibold transition ${
                autoPlay
                  ? "bg-orange-500 text-white hover:bg-orange-600"
                  : "bg-white text-slate-900 ring-1 ring-slate-200 hover:bg-slate-50"
              }`}
            >
              {autoPlay ? "Auto: On" : "Auto: Off"}
            </button>
          </div>

          <h1 className="text-3xl font-semibold tracking-tight sm:text-4xl">Step inside the decision brain</h1>
          <p className="max-w-3xl text-slate-600">
            Click a layer to see what CredAble sees and produces at that stage — explained directly inside the network.
          </p>
        </header>

        <section className="mt-8 overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-sm">
          {/* Top overlay */}
          <div className="pointer-events-none flex items-center justify-between gap-3 px-5 py-4">
            <div className="rounded-full border border-slate-200 bg-white/80 px-3 py-1 text-xs text-slate-600 shadow-sm">
              Highlighting: <span className="font-semibold text-slate-900">Layer {step + 1}</span>
            </div>
            <div className="hidden rounded-full border border-slate-200 bg-white/80 px-3 py-1 text-xs text-slate-600 shadow-sm sm:block">
              Tip: click a layer lane or the buttons below
            </div>
          </div>

          <BrainSVG
            viewBox={viewBox}
            dims={dims}
            nodes={nodes}
            edges={edges}
            nodePx={nodePx}
            activeLayer={step}
            phase={phase}
            reducedMotion={prefersReducedMotion}
            onLayerSelect={selectLayer}
            layerInfo={LAYERS[step]}
            showPopup={showPopup}
            onClosePopup={() => setShowPopup(false)}
          />

          {/* Bottom controls (clickable layers) */}
          <div className="border-t border-slate-200 bg-slate-50 px-5 py-4">
            <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
              <div className="text-sm text-slate-600">
                <span className="font-semibold text-slate-900">{LAYERS[step].subtitle}:</span>{" "}
                <span>
                  {step === 0 && "Inputs stream in and get staged for interpretation."}
                  {step === 1 && "Raw signals become entities, metrics, and coverage."}
                  {step === 2 && "Signals connect into explainable risk/opportunity chains."}
                  {step === 3 && "Policy and confidence gates form a decision-ready view."}
                  {step === 4 && "Outputs leave the brain as drafts, flags, and recommendations."}
                </span>
              </div>

              <div className="flex items-center gap-2">
                <button
                  onClick={() => selectLayer((step - 1 + LAYERS.length) % LAYERS.length)}
                  className="rounded-xl bg-white px-3 py-2 text-sm font-semibold text-slate-900 ring-1 ring-slate-200 hover:bg-slate-50"
                >
                  Prev
                </button>
                <button
                  onClick={() => selectLayer((step + 1) % LAYERS.length)}
                  className="rounded-xl bg-orange-500 px-3 py-2 text-sm font-semibold text-white hover:bg-orange-600"
                >
                  Next
                </button>
              </div>
            </div>

            <div className="mt-3 grid grid-cols-5 gap-2">
              {LAYERS.map((l, i) => (
                <button
                  key={l.key}
                  onClick={() => selectLayer(i)}
                  className={`rounded-xl px-2 py-2 text-xs font-semibold transition ${
                    i === step
                      ? "bg-orange-500 text-white"
                      : "bg-white text-slate-900 ring-1 ring-slate-200 hover:bg-slate-50"
                  }`}
                  aria-label={`Go to ${l.title}`}
                  title={l.title}
                >
                  {i + 1}
                </button>
              ))}
            </div>
          </div>
        </section>

        <div className="mt-5 rounded-xl border border-slate-200 bg-white p-4 text-sm text-slate-600">
          <div className="font-semibold text-slate-900">Design note</div>
          <p className="mt-1">
            This is a <span className="font-medium">conceptual</span> visualization to explain the pipeline clearly.
            It does not claim to reveal model weights.
          </p>
        </div>
      </div>
    </div>
  );
}

// ---------- SVG ----------

function BrainSVG({
  viewBox,
  dims,
  nodes,
  edges,
  nodePx,
  activeLayer,
  phase,
  reducedMotion,
  onLayerSelect,
  layerInfo,
  showPopup,
  onClosePopup,
}: {
  viewBox: string;
  dims: { w: number; h: number };
  nodes: Node[];
  edges: Edge[];
  nodePx: Map<string, { x: number; y: number; r: number; layer: number }>;
  activeLayer: number;
  phase: number;
  reducedMotion: boolean;
  onLayerSelect: (layerIndex: number) => void;
  layerInfo: (typeof LAYERS)[number];
  showPopup: boolean;
  onClosePopup: () => void;
}) {
  const [pingId, setPingId] = useState<string | null>(null);

  useEffect(() => {
    if (!pingId) return;
    const t = window.setTimeout(() => setPingId(null), 900);
    return () => window.clearTimeout(t);
  }, [pingId]);

  const layerEmphasis = (layer: number) => {
    const dist = Math.abs(layer - activeLayer);
    if (dist === 0) return { opacity: 1, width: 1.8, glow: 1 };
    if (dist === 1) return { opacity: 0.35, width: 1.2, glow: 0.4 };
    return { opacity: 0.14, width: 0.9, glow: 0.15 };
  };

  const laneCenters = [0.18, 0.34, 0.5, 0.66, 0.82];
  const bandXs = laneCenters.map((x) => x * dims.w);

  const popup = {
    x: laneCenters[activeLayer] * dims.w,
    y: dims.h * 0.26,
    w: 420,
    h: 210,
  };

  const popupLines = [
    layerInfo.title,
    layerInfo.subtitle,
    ...layerInfo.bullets.map((b) => `• ${b}`),
  ].slice(0, 7);

  return (
    <svg
      viewBox={viewBox}
      className="block h-[560px] w-full bg-white"
      role="img"
      aria-label="Conceptual AI brain visualization"
      onMouseDown={(e) => {
        // close popup if background click
        const target = e.target as HTMLElement;
        const isLane = target?.getAttribute?.("data-lane") === "true";
        if (!isLane) onClosePopup();
      }}
    >
      <defs>
        <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="3" result="blur" />
          <feMerge>
            <feMergeNode in="blur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
        <linearGradient id="brainFill" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stopColor="#F8FAFC" />
          <stop offset="50%" stopColor="#FFFFFF" />
          <stop offset="100%" stopColor="#F8FAFC" />
        </linearGradient>
      </defs>

      {/* Background */}
      <rect x="0" y="0" width={dims.w} height={dims.h} fill="url(#brainFill)" />

      {/* Background texture */}
      <g opacity="0.14">
        {Array.from({ length: 22 }).map((_, i) => (
          <path
            key={i}
            d={`M ${-40} ${30 + i * 28} C ${220} ${30 + i * 28 + 20}, ${420} ${30 + i * 28 - 20}, ${dims.w + 40} ${30 + i * 28}`}
            fill="none"
            stroke="#CBD5E1"
            strokeWidth={0.6}
          />
        ))}
      </g>

      {/* Layer lanes */}
      <g>
        {bandXs.map((x, i) => {
          const emph = layerEmphasis(i);
          const pulse = reducedMotion ? 1 : 0.85 + 0.15 * Math.sin(phase + i);
          const isSelected = i === activeLayer;

          return (
            <g key={i} opacity={Math.max(emph.opacity, 0.18)}>
              <rect
                data-lane="true"
                x={x - 28}
                y={dims.h * 0.11}
                width={56}
                height={dims.h * 0.78}
                rx={18}
                fill={isSelected ? "#FFFFFF" : "#F8FAFC"}
                stroke={isSelected ? "#F97316" : "#E2E8F0"}
                strokeWidth={isSelected ? 1.2 : 0.9}
                opacity={0.95}
                style={{ cursor: "pointer" }}
                onClick={(ev) => {
                  ev.stopPropagation();
                  onLayerSelect(i);
                }}
              />

              <rect
                x={x - 28}
                y={dims.h * 0.11}
                width={56}
                height={dims.h * 0.78}
                rx={18}
                fill="#ffffff"
                opacity={0.05 * (isSelected ? 1 : emph.glow) * pulse}
                pointerEvents="none"
              />

              <g pointerEvents="none">
                <text
                  x={x}
                  y={dims.h * 0.12 + 18}
                  textAnchor="middle"
                  fontFamily="ui-sans-serif, system-ui"
                  fontSize="11"
                  fill={isSelected ? "#F97316" : "#64748B"}
                  opacity={isSelected ? 0.95 : 0.55}
                >
                  Layer {i + 1}
                </text>
              </g>
            </g>
          );
        })}
      </g>

      {/* Edges */}
      <g>
        {edges.map((e, idx) => {
          const A = nodePx.get(e.a);
          const B = nodePx.get(e.b);
          if (!A || !B) return null;

          const emphA = layerEmphasis(A.layer);
          const emphB = layerEmphasis(B.layer);
          const opacity = Math.max(emphA.opacity, emphB.opacity) * (0.18 + 0.55 * e.strength);
          const width = Math.max(emphA.width, emphB.width) * (0.5 + 1.1 * e.strength);

          return (
            <path
              key={idx}
              d={bezier(A.x, A.y, B.x, B.y)}
              fill="none"
              stroke="#60A5FA"
              strokeOpacity={opacity}
              strokeWidth={width}
            />
          );
        })}
      </g>

      {/* Popup (inside network) */}
      {showPopup && (
        <g onMouseDown={(e) => e.stopPropagation()}>
          <rect
            x={popup.x - popup.w / 2 + 4}
            y={popup.y - popup.h / 2 + 6}
            width={popup.w}
            height={popup.h}
            rx={16}
            fill="#000000"
            opacity={0.08}
          />

          <rect
            x={popup.x - popup.w / 2}
            y={popup.y - popup.h / 2}
            width={popup.w}
            height={popup.h}
            rx={16}
            fill="#FFFFFF"
            stroke="#E2E8F0"
          />

          <rect
            x={popup.x - popup.w / 2}
            y={popup.y - popup.h / 2}
            width={6}
            height={popup.h}
            rx={16}
            fill="#F97316"
          />

          <g
            style={{ cursor: "pointer" }}
            onClick={(e) => {
              e.stopPropagation();
              onClosePopup();
            }}
          >
            <circle
              cx={popup.x + popup.w / 2 - 18}
              cy={popup.y - popup.h / 2 + 18}
              r={10}
              fill="#F8FAFC"
              stroke="#E2E8F0"
            />
            <text
              x={popup.x + popup.w / 2 - 18}
              y={popup.y - popup.h / 2 + 22}
              textAnchor="middle"
              fontFamily="ui-sans-serif, system-ui"
              fontSize="14"
              fill="#64748B"
            >
              ×
            </text>
          </g>

          <g fontFamily="ui-sans-serif, system-ui" fontSize="13" fill="#0f172a">
            {popupLines.map((line, idx) => (
              <text
                key={idx}
                x={popup.x - popup.w / 2 + 18}
                y={popup.y - popup.h / 2 + 34 + idx * 22}
                fontWeight={idx === 0 ? 700 : idx === 1 ? 600 : 500}
                fill={idx <= 1 ? (idx === 0 ? "#0f172a" : "#334155") : "#334155"}
              >
                {line}
              </text>
            ))}
          </g>
        </g>
      )}

      {/* Nodes */}
      <g>
        {nodes.map((n) => {
          const p = nodePx.get(n.id);
          if (!p) return null;

          const emph = layerEmphasis(p.layer);
          const isActive = p.layer === activeLayer;
          const pulse = reducedMotion ? 1 : 0.86 + 0.14 * Math.sin(phase + p.x / 120);

          const baseOpacity = n.id.startsWith("in-") || n.id.startsWith("out-") ? 0.9 : 1;
          const opacity = baseOpacity * (0.25 + 0.75 * emph.opacity);

          const ping = pingId === n.id;

          return (
            <g
              key={n.id}
              onClick={() => setPingId(n.id)}
              style={{ cursor: "pointer" }}
              opacity={opacity}
            >
              <circle
                cx={p.x}
                cy={p.y}
                r={p.r + (isActive ? 3.5 : 2.2) * pulse}
                fill="none"
                stroke="#CBD5E1"
                strokeOpacity={isActive ? 0.28 * pulse : 0.12}
                strokeWidth={isActive ? 1.4 : 1}
                filter={isActive ? "url(#softGlow)" : undefined}
              />

              {ping && (
                <circle
                  cx={p.x}
                  cy={p.y}
                  r={p.r + 18}
                  fill="none"
                  stroke="#CBD5E1"
                  strokeOpacity={0.22}
                  strokeWidth={1}
                  filter="url(#softGlow)"
                />
              )}

              <circle
                cx={p.x}
                cy={p.y}
                r={isActive ? 6 : 4}
                fill={isActive ? "#F97316" : "#3B82F6"}
                opacity={isActive ? 0.95 : 0.6}
              />
            </g>
          );
        })}
      </g>

      {/* Labels for inputs/outputs */}
      <g fontFamily="ui-sans-serif, system-ui" fontSize="12" fill="#64748B" opacity="0.8">
        <text x={dims.w * 0.06} y={dims.h * 0.12}>
          Inputs
        </text>
        <text x={dims.w * 0.86} y={dims.h * 0.12}>
          Outputs
        </text>
      </g>
    </svg>
  );
}

// ---------- Lightweight self-tests ----------
// These tests are safe to keep in the file; they do not run in production builds.

function runSelfTests() {
  // bezier should return a valid SVG path starting with M and containing C
  const p = bezier(0, 0, 10, 10);
  if (!p.startsWith("M ") || !p.includes(" C ")) {
    throw new Error("bezier() output is not a valid cubic path");
  }

  // graph should have core nodes for each layer
  const g = buildBrainGraph(1);
  const layers = new Set(g.nodes.filter((n) => n.id.startsWith("n-")).map((n) => n.layer));
  for (let i = 0; i < 5; i++) {
    if (!layers.has(i)) throw new Error(`Missing core nodes for layer ${i}`);
  }

  // edges should reference existing nodes
  const ids = new Set(g.nodes.map((n) => n.id));
  for (const e of g.edges) {
    if (!ids.has(e.a) || !ids.has(e.b)) throw new Error("Edge references missing node");
  }
}

// Run tests only in explicit test mode
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const __env: any = (typeof process !== "undefined" && (process as any).env) || {};
if (__env.NODE_ENV === "test") {
  runSelfTests();
}